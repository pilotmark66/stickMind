###  **Q1.** 使用上面的编码树对序列 `0101100011` 进行解码。

O :1

N : 00

M : 010

S : 011

0101100011 MOONS

###  **Q2.** 为上述编码树制作一个表格，列出每个字符及其分配的位序列。使用表格对字符串“SONS”进行编码。

| 字符 | 编码 |
| ---- | ---- |
| O    | 1    |
| N    | 00   |
| M    | 010  |
| S    | 011  |

011100011



### **Q3.** 哈夫曼代码遵循**前缀属性（Prefix-Free）**：任意字符的编码位序列都不是其他字符的前缀。编码树的什么特征表明它服从前缀属性？

内部节点不存储字符

### **Q4.** 将右上方的编码树展平为位序列和字符序列。

- 



### **Q5.** 展开序列 `110100100` 和 `FLERA` 以重建原始编码树。



### **Q6.** 为输入“BOOKKEEPER”构造哈夫曼编码树。







```c++

```





### **Q7**. 哈夫曼编码树中的节点有两类，两个非空子节点或没有子节点。为什么哈夫曼树中的节点只有一个非空子节点没有意义？

只有一个非空子节点，该子节点可以直接替代根节点







